프로그램을 검토하고 리팩토링하면서 수정이 필요한 부분을 체크하는 항목은 다음과 같다.

## 주석

### 부적절한 정보

코드와 설계에 기술적인 설명을 부연할 수 있는 메타 정보만 주석으로 남겨야 하지, 다른 시스템에 저장해야할 정보들(소스 코드 관리 시스템, 버그 추적 시스템, 이슈 추적 시스템, 기타 기록 관리 시스템)을 주석으로 남기는 것은 부적절하다.

### 쓸모 없는 주석

오래된 주석, 의도에 맞지 않는 주석은 아예 달지 않는 편이 좋다. 코드와 무관하게 작성된 주석은 코드를 잘못된 방향으로 이끈다.

### 중복된 주석

코드만으로도 충분히 설명이 가능한데, 주석으로 중복되게 설명하는 것은 옳지 않다.

### 성의 없는 주석

주석의 내용을 작성할 때, 단어 하나하나 신중하게 선택하고 문법과 구두점도 올바르게 사용해야 한다. 간결하고 명료하면서도 올바르게 내용을 설명해야 한다.

### 주석 처리된 코드

주석으로 처리된 코드가 나오면 의도를 파악하기 어렵고 모듈의 가독성을 낮출 수 있다. 주석으로 처리된 코드는 제때 처리하는 것이 좋다.

## 환경

### 여러 단계로 빌드해야 한다

빌드는 한 단계로 끝나야 한다. 불가해한 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 한다. 온갖 jar 파일, xml 파일, 기타 시스템에 필요한 파일을 찾느라 여러 작업을 수행하면 안된다. 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

### 여러 단계로 테스트해야 한다

모든 단위 테스트는 한 명령으로 돌릴 수 있어야 한다. IDE의 기능을 활용해 모든 테스트를 한번에 돌리면 가장 이상적이다. 테스트 실행 환경은 빠르고 쉽고 명백해야 한다.

## 함수

### 너무 많은 인수

함수의 인수가 적으면 적을수록 좋다. 넷 이상은 그 가치가 의심스러우므로 개선이 필요하다. 인수가 많을수록 그 의미를 파악하기 어려울 뿐만 아니라 결정적으로 테스트를 수행할 때 인자의 수가 늘어난 만큼 테스트 케이스가 많아진다. 너무 많은 인수를 받는 함수는 외부 여러 요소에 의존하는 경향이 있기 때문에 재사용성과 모듈화를 해친다.

### 출력 인수

일반적으로 사람들은 인수를 입력으로 간주한다. 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다. 출력 인수를 사용하는 것이 아니라

### 플래그 인수

boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거이기 때문에 최대한 피해야 한다. 조건 분기로 사용되는데(true? false?) 각 조건에 따른 로직을 하나의 함수 안에서 수행하기 때문에 SRP를 위반한다. 상태나 전략을 전달해야 할 때에는 enum을 활용할 수도 있다.

### 죽은 함수

호출하지 않는 함수는 메모리 낭비이다. 소스 코드 관리 시스템이 있기 때문에 과감히 삭제하여도 괜찮다.

## 일반

### 한 소스 파일에 여러 언어를 사용한다

어떤 자바 소스 파일은 xml, html, yaml, javadoc, javascript, 영어 등 여러 언어를 포함한다. 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. 하지만 현실적으로는 여러 언어가 포함될 수밖에 없다. 노력을 기울여 최대한 언어 수와 범위를 줄이도록 해야 한다.

### 당연한 동작을 구현하지 않는다

최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. 요일 문자열은 요일을 나타내는 enum 클래스를 활용할 수 있다. 이처럼 읽는 사람으로 하여금 함수 기능을 직관적으로 파악할 수 있게 하는 것이 중요하다.

### 경계를 올바로 처리하지 않는다

스스로의 직관에 의존하지 말고 모든 경계 조건을 찾아 내어 해당 조건들을 모두 테스트할 수 있는 테스트 케이스를 작성해야 한다.

### 안전 절차 무시

컴파일러 경고 일부 혹은 전부를 꺼버리면 빌드가 쉬워질지라도 자칫하면 끝없는 디버깅에 시달린다. 실패하는 테스트 케이스를 제끼고 나중으로 미루는 태도는 예측 불가능한 미래에 문제가 발생하더라도 대비가 어렵다.

### 중복

소프트웨어 설계에서 가장 중요한 요소는 중복을 제거하는 것이다.(DRY 원칙) 모든 테스트를 통과한다 다음으로 중요한 원칙이다. 중복을 발견하면 추상화를 고려해야 한다. 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다. 이후에는 확장성을 고려할 수 있을 것이다. 똑같은 코드가 여러 차례 나오는 중복은 간단한 함수로 분리해 사용한다. switch/case 나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복은 다형성으로 대체할 수 있다. 알고리즘이 유사하나 코드가 서로 다른 중복은 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거할 수 있다.

### 추상화 수준이 올바르지 못하다

추상화는 저차원 상세 개념에서 고차원 일반 개념으로 분리한다. 세부 구현과 관련된 상수, 변수, 유틸리티 함수는 파생 클래스에 넣는다. 기초 클래스는 구현 정보에 무지해야 한다. 소스 파일, 컴포넌트 모듈도 마찬가지로 고차원과 저차원 개념을 섞지 않고 적절하게 분리한다.

### 기초 클래스가 파생 클래스에 의존한다

일반적으로는 파생 클래스가 기초 클래스에 의존하는 것이 바람직하다. 기초 클래스는 파생 클래스를 아예 몰라야 한다.

하지만 예외도 존재한다. 상태 전이 모델처럼 파생 클래스의 개수가 고정되어 있으며, 이들이 함께 묶여 의미를 갖는 경우 기초 클래스가 파생 클래스를 직접 참조하게 되는 구조가 발생한다. 이는 상태 전이 시 다음 상태 객체를 직접 생성하면서 다른 파생 클래스를 참조하게 되기 때문이다. 결과적으로 구조적인 순환 의존이 생기고, 이는 하나의 bounded context 안에서 해결되는 것이 일반적이다.

가장 이상적인 배포는 기초 클래스와 파생 클래스가 서로 다른 jar로 배포되는 것이다. 이렇게 jar를 분리하면, 기초 클래스의 jar를 수정하지 않고도 새로운 기능 추가나 기존 파생 클래스 수정이 가능해져, 시스템 확장성과 안정성이 크게 향상된다.

### 과도한 정보

잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다. 부실하게 정의된 인터페이스는 반드시 호출해야 하는 온갖 함수를 제공한다. 그래서 결합도가 높다. 클래스가 제공하는 메서드 수, 클래스 안에 들어있는 인스턴스 변수 수, 함수가 아는 변수 수 모두 작을수록 좋다. 하위 클래스에서 필요하다는 이유로 protected 변수나 함수를 마구 생성해서는 안된다.

### 죽은 코드

실행되지 않는 코드를 의미하는데, 불가능한 조건을 확인하는 if문과 throw 문이 없는 try 문에서 catch 블록이 그 예시이다. 시스템에서 제거하는 것이 좋다.

### 수직 분리

변수와 함수는 사용되는 위치에 가깝게 정의한다. 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다. 비공개 함수는 처음으로 호출한 직후에 정의한다. 이는 쉽게 눈에 띄게 하기 위함이다.

### 일관성 부족

최소 놀람의 원칙 중 하나로 표기법은 신중하게 선택하며 신중하게 따라야 한다. 간단한 일관성만으로도 코드를 읽고 수정하기 쉬워진다.

### 잡동사니

아무도 사용하지 않는 변수, 아무도 호출하지 않는 함수, 정보를 제공하지 못하는 주석 등 잡동사니를 삭제해야 한다.

### 인위적인 결합

enum과 같은 클래스는 특정 클래스에 속할 이유가 없다. 만약에 속해야 한다면 enum을 사용하는 코드가 특정 클래스를 알아야 한다. 범용 static 함수도 마찬가지이다. 직접적인 상호작용이 없는 두 모듈 상이에서 인위적인 결합을 하는 것은 의존성을 쓸데없이 높인다.

### 기능 욕심

클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다. 기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하므로 별다른 문제가 없다면 제거하는 편이 좋다. 어쩔 수 없는 경우를 살펴보면 이는 결국 특정 메서드의 변경이 불필요하게 연결된 클래스의 수정까지 가게 된다.

### 선택자 인수

부울, enum, int 등 함수 동작을 제어하려는 인수는 하나 같이 바람직하지 않다. 일반적으로 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.

### 모호한 의도

의도가 분명하지 않은 코드는 관리가 어렵다.

### 잘못 지운 책임

코드를 배치하는 위치도 신경써야 한다. PI 상수는 삼각함수를 선언한 클래스에 넣어야 맞지, Math, Circle 클래스에 들어가는게 아니다. OVERTIME_RATE 또한 시간 수당 계산 클래스에 들어가는 것이 맞다.

### 부적절한 static 함수

Math.max(double a, double b)는 좋은 static 메서드의 예시인데, 이는 일반적으로 재정의할 가능성이 낮기 때문이다.(물론 수정이 불가능하진 않다)

HourlyPayCalculator.calculatePay(employee, overtimeRate); 와 같은 메서느는 static 함수로 여기기에는 다른 요소들이 존재할 수 있다. 시간 당 수당을 계산하는 방식이 다를 수 있다. 초과 근무와 그렇지 않은 경우를 따로 계산하고 싶을 수 있다. 그렇기 때문에 이는 Employee 클래스에 속하는 인스턴스 함수여야 한다.

재정의 가능성을 체크해 인스턴스 함수로 활용하거나 static 함수로 활용할 수 있다.

### 서술적 변수

프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다. key, value와 같이 서술적인 변수 이름은 많이 사용하면 할수록 좋다. 이로 인해 모듈이 순식간에 읽기 쉬운 모듈로 진화한다.

### 이름과 기능이 일치하는 함수

기능의 특징에 맞게 이름을 잘 설정하면 문서를 찾아본다든지 코드를 해석하지 않아도 된다.

### 알고리즘을 이해하라

구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라. 테스트 케이스를 모두 통과한다는 사실만으로는 부족하다. 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

### 논리적 의존성은 물리적으로 드러내라

논리적인 의존성뿐만 아니라 물리적 의존성도 있어야 한다.

단순히 논리적 의존성이 있는 것만으로는 충분하지 않다는 것이다. 논리적인 의존성이 있다면 반드시 물리적인 의존성도 함께 존재해야 한다. 즉, 인터페이스 설계, 메서드 호출, 생성자 주입, 모듈 의존성 선언 등을 통해 그 관계가 코드와 빌드 구조 상에서 드러나야 한다. 그래야만 시스템의 구조가 의존성을 명확히 반영하고, 확장이나 테스트, 변경이 용이해진다.

결론적으로, 논리적으로 연결되어 있는 객체나 모듈은 반드시 그 관계를 코드와 구조에도 반영해야 한다. 이는 숨겨진 가정을 제거하고, 코드의 명료성과 견고함을 높이며, 변경에 강한 구조를 설계하는 데 핵심적인 원칙이다.

### If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

새 유형을 추가할 확률보다 새 함수를 추가할 확률이 높은 코드에서는 switch 문이 적합하다고 말했었지만 그보다 더 먼저 고려해야 하는 것은 다형성이다. 유형보다 함수가 더 쉽게 변하는 경우는 극히 드물다. 그러므로 switch 문을 모두 의심해봐야 한다.

### 표준 표기법을 따르라

인스턴스 변수 이름을 선언하는 위치부터 클래스/메서드/변수 이름을 정하는 방법, 괄호를 넣는 위치까지 표준을 명시해야 한다. 이를 따르는 것은 팀원들과의 협업에 있어 매우 중요하다.

### 매직 숫자는 명명된 상수로 교체하라

Math.PI와 같이 이미 정의된 상수는 최대한 활용하고 그렇지 않으면 상수로 교체하여 숫자의 의미가 무엇인지 명확히 해야 한다.

### 정확하라

검색 결과 중 첫 번째 결과만 유일한 결과롤 간주하는 행동은 피해야 한다. 코드에서 무언가를 결정할 때 정확히 결정한다. 호출하는 함수가 null을 반환할지도 모른다면 null을 반드시 점검해야 한다. 코드에서 모호성과 부정확은 의견차나 게으름의 결과이다.

### 관례보다 구조를 사용하라

enum와 switch 방식은 동작을 한 곳에 몰아넣고 새 타입 추가 시 코드를 변경하게 만들뿐만 아니라 switch 중복 위험도 있다. 반면, **추**상 메서드를 가진 기초 클래스 다형성 기반 설계는 구현 강제, 책임 분리, 코드 변경 최소화 이러한 이유로 더 좋은 설계이다.

### 조건을 캡슐화하라

조건의 의도를 분명히 밝히는 함수가 좋다. if (shouldBeDeleted(timer)) 가 if (timer.hasExpired() && !timer.isRecurrent()) 보다 좋다.

### 부정 조건은 피하라

부정조건은 긍정조건보다 이해하기 어렵다. 가능하면 긍정 조건을 활용하라.

### 함수는 한 가지만 해야 한다

한 함수 안에 여러 단락을 이어 일련의 작업을 수행하고 싶을 때가 있지만 SRP 원칙을 위반할 수 있다. 각 함수는 한 가지 임무만 수행하게 하였을 때 유지보수에 유리하다.

### 숨겨진 시간적인 결합

함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다. 연결 소자를 생성해 시간적인 결합을 노출하는 방식을 사용하면 순서가 뒤바뀔 일이 발생하지 않는다.

### 일관성을 유지하라

코드 구조의 일관성을 유지해야 한다. 다른 클래스의 유틸리티가 아닌 Public 클래스는 자신이 아닌 클래스 범위 안에서 선언하면 안된다. 패키지 최상위 수준에 public 클래스로 선언하는 관례가 일반적이다.

### 경계 조건을 캡슐화하라

코드 곳곳에 있는 if문 안의 조건들은 외부에서는 무엇을 하는지 확인하는 용도로만 활용하고 내부적인 로직은 캡슐화해서 관리하는 것이 좋다.

### 함수는 추상화 수준을 한 단계만 내려가야 한다

함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

하나의 함수 안에는 "한 가지 추상화 수준"만 담아야 하며, 함수의 이름이 말하는 수준보다 정확히 한 단계만 구체적인 작업만 수행해야 한다. 더 세부적인 동작은 또 다른 함수로 분리해야 한다.

예를 들어 보고서 작성 모듈 안에 보고서를 작성하는 작업이라는 대제목과 데이터를 문자열로 만들고 반복문 돌리는 작업, 그리고 이메일을 보내는 작업이 모두 있는 상황이다. 이는 추상 클래스와 구현 클래스가 섞여 있는 형태로 되어 있어 분리하자면 아래와 같다.

추상 클래스(고수준) : 보고서 작성 작업 지시와 이메일 전송

구현 클래스-1(중간수준) : 보고서 작성에 대한 작업인 제목 작성 및 내용 작성

구현 클래스-1-1(저수준) : 내용 작성의 세부 작업인 데이터를 문자열로 만들고 반복문 수행

### 설정 정보는 최상위 단계에 둬라

최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 넣지 말아야 한다. 설정 관련 상수를 최상위 단계에 두면 저수준에서 찾을 필요도 없고 변경도 쉽다.

### 추이적 탐색을 피하라

a.getB().getC().doSomething(); 와 같은 코드는 좋지 않다. 주변 모듈을 활용하더라도 a가 c를 알 필요는 없다. 자신이 직접 사용하는 모듈만 알아야 한다. 모듈 간의 연결이 깊어지면 중간에 모듈을 추가하려면 뒤의 모듈까지 모두 수정해야 한다. myCollaborator.doSomething(); 과 같이 간단한 코드로 충분해야 한다.

## 자바

### 긴 import 목록을 피하고 와일드카드를 사용하라

패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 전체 패키지를 가져오는 것이 좋다. 명시적인 import 문은 강한 의존성을 생성하지만 와일드카드는 그렇지 않다. 특정 클래스의 존재가 필요하진 않다. 단순히 검색 경로만을 추가하기 때문에 모듈 간에 결합성이 낮아진다.

### 상수는 상속하지 않는다

상수를 인터페이스에 넣은 다음 그 인터페이스를 상속해 해당 상수를 사용하는 것은 좋지 않다. 상수를 상속 계층 맨 위에 숨겨놓으면 단계적으로 탐색해야 하기 때문에 번거롭다. static import를 활용해 상수 모듈을 불러와 사용하는 방법을 사용한다.

### 상수 대 Enum

자바 5부터는 enum을 제공한다. 코드의 의미를 살릴 수 있을 뿐만 아니라 메서드와 필드도 사용 가능해 그 활용성이 높다.

## 이름

### 서술적인 이름을 사용하라

소프트웨어의 가독성 90%를 차지하는 이 이름 짓기 행위는 유지보수 측면에서 매우 중요한 역할을 한다.

### 적절한 추상화 수준에서 이름을 선택하라

구현을 드러내는 이름은 피하고 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택해야 한다.

### 가능하다면 표준 명명법을 사용하라

DECORATOR 패턴을 활용한다면 장식하는 클래스 이름에 Decorator라는 단어를 사용해야 한다. 이외에도 자바에서 객체를 문자열로 변환하는 함수는 toString이라는 이름을 많이 쓴다. 프로젝트에 유효한 의미가 담긴 이름을 많이 쓸수록 독자가 코드를 이해하기 쉬워진다.

### 명확한 이름

함수는 변수의 목적을 명확히 하는 이름을 선택한다. 이름이 길어지더라도 서술성이 단점을 메꿀 수 있다.

### 긴 범위는 긴 이름을 사용하라

범위가 작으면 아주 짧은 이름을 사용하고 범위가 길어지면 이름도 길게 사용한다.

### 인코딩을 피하라

이름앞에 m_이나 f와 같은 접두어를 사용하는 것은 불필요하다. 중복된 정보를 제공하는 경우가 많고 독자에게 혼란을 야기할 수 있다.

### 이름으로 부수 효과를 설명하라

여러 작업을 수행하는 함수에다 동사 하나만 사용하면 그 의미가 코드를 온전히 설명하지 못한다.

## 테스트

### 불충분한 테스트

테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다. 테스트 케이스가 확인되지 않은 조건이나 검증되지 않은 계산이 있다면 해당 모듈은 불안정하다.

### 커버리지 도구를 사용하라!

테스트의 구멍(사용하지 않은 메서드 탐색)을 찾을 수 있다. 전혀 실행되지 않는 if문 혹은 case문 블록을 찾을 수 있다.

### 사소한 테스트를 건너뛰지 마라

사소한 테스트는 짜기 쉽다. 이에 대한 문서를 작성하는 것은 구현에 드는 비용을 넘어선다.

### 무시한 테스트는 모호함을 뜻한다

불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.

### 경계 조건을 테스트하라

알고리즘의 중앙 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다.

### 버그 주변은 철저히 테스트하라

버그는 모이는 경향이 있기에 한 함수에서 버그를 발견하게 되면 그 함수에 대한 테스트를 철저하게 진행해야 한다.

### 실패 패턴을 살펴라

테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다. 테스트 보고서를 통해 패턴을 파악하면 문제를 빠르게 진단할 수 있다.

### 테스트 커버리지 패턴을 살펴라

통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 케이스의 원인이 드러난다.

### 테스트는 빨라야 한다

느린 테스트 케이스는 실행하지 않게 되니 빠르게 돌아가도록 코드를 수정해야 한다.