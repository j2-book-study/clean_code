스레드들이 자바 코드 한 줄을 거쳐가는 경로는 수없이 많은데, 공유 자원에 대한 계산이 있는 경우는 일부 경로에서 잘못된 결과를 도출한다.

JIT 컴파일러가 바이트 코드를 처리하는 방식과 자바 메모리 모델이 원자로 간주하는 최소 단위에 따라 발생할 수 있는 경로의 수가 정해진다.

바이트 코드만 고려했을 때, 두 스레드가 증가 로직만 담긴 메서드를 실행하는 잠재적인 경로는 12870개에 달한다. 변수 종류에 따라서(ex. long, int) 경로 수는 더욱 증가한다.

### 동시성 방어 원칙

- 단일 책임 원칙
    - 동시성 관련 코드는 비즈니스 로직과 분리해야 한다.
    
    1) 기존의 동시성 제어와 비즈니스 로직이 혼재된 구조
    
    ```java
    public class Inventory {
        private int stock = 100;
    
        public synchronized boolean tryPurchase() {
            if (stock > 0) {
                stock--;
                return true;
            }
            return false;
        }
    }
    ```
    
    1. 동시성 제어와 비즈니스 로직이 분리된 구조
    
    ```java
    // 비즈니스 로직
    public class Inventory {
        private int stock = 100;
    
        public boolean decrease() {
            if (stock > 0) {
                stock--;
                return true;
            }
            return false;
        }
    }
    ```
    
    ```java
    // Inventory를 감싸서 동시성 제어 책임을 추가한 Wrapper 클래스
    public class SynchronizedInventory {
        private final Inventory inventory = new Inventory();
    
        public synchronized boolean safeDecrease() {
            return inventory.decrease();
        }
    }
    ```
    
- 자료 범위를 제한하라
    - 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호
    - 임계영역을 최소화하는 기술이 중요
    - 자료를 캡슐화하고 공유 자료를 최소화
- 자료 사본을 사용하라
    - 공유하지 않기(객체를 복사해 사용한 후 해당 사본에서 결과를 가져오는 방법 활용)
- 스레드는 가능한 독립적으로 구현하라
    - 다른 스레드와 자료를 공유하지 않는다.
    - 클라이언트 요청마다 고유한 `HttpServletRequest`와 `HttpServletResponse` 객체가 생성되어 서블릿 메서드에 전달되기 때문에, 서블릿 인스턴스는 여러 스레드가 동시에 접근하더라도 request, response 기반 로직은 서로 간섭되지 않는다. (즉, 각 요청은 독립적인 스레드에서 처리되며, 해당 요청에 대한 데이터는 다른 요청과 공유되지 않는다.)

### 라이브러리를 활용한 동시성 제어

자바 5에서는 concurrent 패키지가 제공하는 클래스를 활용하면 다중 스레드 환경에서 안정적이면서도 좋은 성능으로 제어가 가능하다.(ConcurrentHashMap은 실제로 HashMap보다 빠르다)

좀 더 복잡한 동시성 설계를 지원하고자 다른 클래스도 자바 5에서 추가되었다.

- ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 푸는 락이다.
- Semaphore: 전형적인 세마포다. 개수가 있는 락이다.
- CountDownLatch: 지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제하는 락이다. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.

### 실행 모델을 이해하기

생산자-소비자, 읽기-쓰기와 같은 다중 스레드 프로그래밍에서 사용하는 실행 모델에서는 주의해야할 점이 있다.

- 생산자 스레드는 대기열에 정보를 채운 다음 소비자 스레드에게 “대기열에 정보가 있다”는 시그널을 보내고 소비자 스레드는 대기열에서 정보를 읽어들인 후 “대기열에 빈 공간이 있다”는 시그널을 보낸다. → 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재한다.
- 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드가 버퍼를 읽지 않으려면, 마찬가지로 읽기 스레드가 버퍼를 읽는 동안 쓰기 스레드가 버퍼를 갱신하지 않으려면 복잡한 균형잡기가 필요한다. 읽기 스레드에게 계속 우선권이 가게 되면 쓰기 스레드는 기아 상태에 빠지고, 반대로 쓰기 스레드에게 우선권을 줘 계속 이어진다면 처리율이 떨어질 수 있다.

이처럼 공유 자원을 여러 스레드에서 점유하려고 하는 시도를 하며 경쟁한다. 이를 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하를 겪을 수 있다.

### 동기화하는 메서드 사이의 의존성을 이해하기

공유 객체 하나에 메서드 하나만 활용하게끔 설계하려고 노력하지만, 여러 메서드가 공유 객체 하나에 의존하는 상황도 생긴다. 이때 아래와 같은 사항을 고려해야 한다.

- 클라이언트에서 잠금: 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
- 서버에서 잠금: 서버에다 “서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는” 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
- 연결서버: 잠금을 수행하는 중간 단계를 생성해 ‘서버에서 잠금’ 방식과 유사하지만 원래 서버는 변경하지 않는다.

### 동기화하는 부분을 작게 구성

동기화 키워드는 한 번에 한 스레드만 실행 가능하기 때문에 지연과 부하를 가중시킨다. 따라서 반드시 설정해야 하는 임계영역에 대해 보호하는 것으로 최소화해야한다.

### 올바른 종료 코드 구현하기

부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다 자원을 해제하고 종료하는 시스템이 있다고 가정한다. 만약 자식 스레드 중 하나가 데드락에 걸리면 부모 스레드는 영원히 기다리게 돼 시스템이 종료되지 않는 문제가 발생한다. → 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다.

### 스레드 코드 테스트하기

공유 자원을 사용하는 스레드가 2개 이상이라면 코드 테스트의 역할이 매우 중요하다.

- 말이 안되는 실패는 잠정적인 스레드 문제로 취급해 ‘일회성’ 문제라고만 생각하지 말고 개선해야 한다.
- 스레드가 호출하는 POJO를 만들어 스레드 환경 밖에서 코드가 제대로 도는지 확인한다.
- 다양한 환경에서(한 스레드, 여러 스레드, 느린 속도, 빠른 속도 등) 작동할 수 있게 쉽게 구현해야 한다.
- 프로세서 수보다 많은 스레드를 돌려 스와핑이 많이 일어나는 환경에서 임계영역에 대한 문제가 발생하는지 체크해야 한다.
- 스레드 버그가 산발적이고 우발적이고 재현이 어렵기 때문에(너무 많은 경로가 있는데 버그는 그 중 일부) 보조 코드를 추가해 실행 순서를 바꿔 강제로 실패를 만들어 본다.

결론적으로, 다중 스레드 코드를 올바르게 작성하려면 각별히 주의해야 한다.

- SRP 준수해 POJO로 스레드를 모르는 코드와 스레드를 아는 코드 분리한다. 각자 목적에 맞게 테스트 진행한다.
- 동시성 오류를 일으키는 잠재적 원인을 이해한다.
- 공유 자원과 그렇지 않은 자원의 영역을 명확히 분리하고, 공유 자원을 최소화 하여 클라이언트에게 그 책임이 넘어가지 않게 해야한다.
- 보조 코드를 활용해 다양한 테스트 환경에서 문제 발생을 확인해야 한다.